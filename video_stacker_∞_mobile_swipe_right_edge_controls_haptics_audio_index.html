<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>VIDEO_STACKER_∞</title>
<style>
  :root{
    --green:#19ff48; --green-d:#0bbb31; --bg:#000; --panel:#0b0b0b; --grid:#003300; --gridHi:#00ff00;
    --hud:#8bff9b; --soft:#111; --shadow:rgba(0,0,0,.55);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{margin:0; background:var(--bg); font:14px/1.2 "SFMono-Regular","Courier New",monospace; color:#ddd; overflow:hidden; touch-action:none;}
  canvas{display:block; width:100vw; height:100vh}

  /* HUD top-left, compact */
  .hud{position:fixed; left:calc(env(safe-area-inset-left,0) + 10px); top:calc(env(safe-area-inset-top,0) + 10px); z-index:10; color:var(--hud); text-shadow:0 0 10px black}
  .hud .line{display:flex;gap:10px;align-items:center}
  .score{font-weight:900; font-size:22px; letter-spacing:.5px}
  .meter{height:8px; width:min(42vw,220px); border:1px solid var(--green); background:#222; position:relative}
  .meter>i{display:block; height:100%; width:100%; background:linear-gradient(90deg,#f33,#ff0,#1f5,#0f5); transition:width .2s}
  .tag{opacity:.7}
  .preview{width:84px; height:48px; border:1px solid var(--green); background:#101010; margin-top:6px}

  /* Right-edge control column */
  .controls{position:fixed; right:calc(env(safe-area-inset-right,0) + 8px); top:50%; transform:translateY(-50%); z-index:12; display:flex; flex-direction:column; gap:10px; align-items:flex-end; pointer-events:auto}
  .btn{background:var(--panel); color:var(--green); border:2px solid var(--green); padding:10px 12px; font-weight:800; box-shadow:0 6px 16px var(--shadow); border-radius:12px; min-width:84px; text-align:center}
  .btn.small{min-width:auto; padding:8px 10px; font-size:12px}
  .btn:active{background:var(--green); color:#000; transform:translateY(1px)}
  .btnRow{display:flex; gap:8px}
  .controls.fade{opacity:.45}

  /* Gesture helper pill (top-right) */
  .hint{position:fixed; right:calc(env(safe-area-inset-right,0) + 8px); top:calc(env(safe-area-inset-top,0) + 8px); z-index:9; color:#9affac; background:rgba(0,0,0,.55); border:1px solid #144; padding:6px 10px; border-radius:20px; font-size:12px}

  /* Game over card */
  .over{position:fixed; inset:0; display:none; place-items:center; z-index:30;}
  .over .card{background:rgba(0,0,0,.92); border:3px solid var(--green); color:var(--green); padding:28px; width:min(88vw,420px); text-align:center; border-radius:18px; box-shadow:0 20px 60px var(--shadow)}
  .over h1{margin:0 0 8px; font-size:28px}
  .over .btn{margin-top:12px}

  /* Keep center free for stack */
  .safe{position:fixed; inset:0; pointer-events:none}
  .safe:after{ /* visual debug off by default; set opacity to .1 if needed */
    content:""; position:absolute; left:0; right:110px; top:0; bottom:0; opacity:0; background:transparent
  }

  @media (min-width:720px){ .btn{min-width:108px} }
</style>
</head>
<body>
<canvas id="view"></canvas>
<div class="safe" aria-hidden="true"></div>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="score" id="hudScore">SCORE: 0</div>
  <div class="line"><span class="tag">HEIGHT:</span><span id="hudH">0</span>m <span class="tag">STREAK:</span><span id="hudS">0</span>x <span class="tag">HIGH:</span><span id="hudHi">0</span></div>
  <div class="meter"><i id="hudStab" style="width:100%"></i></div>
  <div class="tag">NEXT</div>
  <div class="preview" id="preview"></div>
</div>

<!-- Gesture hint -->
<div class="hint" id="hint">swipe ↑ drop • swipe ◀/▶ nudge • swipe ↓ cull</div>

<!-- Controls (right edge) -->
<div class="controls" id="controls">
  <button class="btn" id="bDrop">DROP</button>
  <div class="btnRow">
    <button class="btn small" id="bLeft">◀</button>
    <button class="btn small" id="bRight">▶</button>
  </div>
  <button class="btn" id="bCull">CULL</button>
  <div class="btnRow">
    <button class="btn small" id="bView">VIEW ⟲</button>
    <button class="btn small" id="bMute">MUTE</button>
  </div>
</div>

<!-- Game Over -->
<div class="over" id="over"><div class="card">
  <h1>GAME OVER</h1>
  <div id="final">—</div>
  <button class="btn" id="bRestart">RESTART</button>
</div></div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
import * as CANNON from 'https://cdn.skypack.dev/cannon-es@0.20.0';

/***** Config *****/
const TV={w:.6,d:.45,h:.4};
const GAP=.05, LIMIT=.22, WINDOW_K=6, ALPHA=.7;
const FEED=[ '/videos/a.mp4','/videos/b.mp4','/videos/c.mp4' ];

/***** Cameras (define BEFORE any call to setCam) *****/
const cams=[
  {pos:[0,2,4], look:[0,1,0]},
  {pos:[-3,2,3], look:[0,1,0]},
  {pos:[3,2,3], look:[0,1,0]},
  {pos:[0,0.7,3], look:[0,1,0]},
  {pos:[0,6,0.1], look:[0,1,0]},
];
function setCam(i){ const c=cams[i]||cams[0]; camera.position.set(...c.pos); camera.lookAt(...c.look); }

/***** State *****/
let scene,camera,renderer,world,clock; 
let tvs=[], falling=null; 
let score=0, height=0, streak=0, stability=1, gameOver=false, muted=false, feedI=0, camI=0; 
let high=Number(localStorage.getItem('tv_hi')||0);
let lastTouch=Date.now();

/***** Audio (tiny synth, no assets) *****/
const actx = new (window.AudioContext||window.webkitAudioContext)();
function beep(type='sine',freq=440,dur=0.06,gain=0.02){
  if(actx.state==='suspended') actx.resume();
  const o=actx.createOscillator(), g=actx.createGain();
  o.type=type; o.frequency.value=freq; g.gain.value=gain; 
  o.connect(g).connect(actx.destination); o.start(); o.stop(actx.currentTime+dur);
}
function sndDrop(){beep('square',320,.07,.03)}
function sndNudge(){beep('triangle',520,.05,.02)}
function sndThump(){beep('sine',90,.09,.04)}
function sndOver(){beep('sawtooth',220,.25,.05)}

/***** Haptics *****/
const buzz = (p)=>{ if(navigator.vibrate) navigator.vibrate(p) };

/***** Shaders (noise + CRT glass) *****/
const v=`varying vec2 vUv; void main(){vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`;
const fNoise=`varying vec2 vUv; uniform float t; float r(vec2 s){return fract(sin(dot(s,vec2(12.9898,78.233)))*43758.5453);} void main(){float n=r(vUv*vec2(640.,360.)+t); gl_FragColor=vec4(vec3(n),1.);}`;
const fGlass=`varying vec2 vUv; uniform sampler2D tex; uniform float t; uniform float pulse; void main(){vec2 u=vUv; u.x+=sin(u.y*110.+t*5.)*.002; float scan=sin(u.y*800.)*.03; vec4 c=texture2D(tex,u); c.rgb+=scan; float chr=sin(t*3.+u.y*20.)*.02; c.r+=chr; c.b-=chr; c.rgb=mix(c.rgb,vec3(1.),pulse*.6*(1.-u.y)); gl_FragColor=c;}`;

/***** Setup *****/
const view=document.getElementById('view');
renderer=new THREE.WebGLRenderer({canvas:view,antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,1.7));
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled=true;
scene=new THREE.Scene();
scene.background=new THREE.Color(0x0a0a0a);
scene.fog=new THREE.Fog(0x0a0a0a,5,16);

camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,.1,100); 
setCam(0); // safe now that cams is defined
clock=new THREE.Clock();

const amb=new THREE.AmbientLight(0xffffff,.9); scene.add(amb);
const key=new THREE.DirectionalLight(0xffffff,.9); key.position.set(3,6,4); key.castShadow=true; scene.add(key);
const fill=new THREE.DirectionalLight(0x66aaff,.35); fill.position.set(-3,2,-3); scene.add(fill);

// Floor + grid
world=new CANNON.World(); world.gravity.set(0,-9.82,0); world.broadphase=new CANNON.SAPBroadphase(world); world.allowSleep=true; world.defaultContactMaterial.friction=.6; world.defaultContactMaterial.restitution=.05;
const gnd=new CANNON.Body({mass:0,shape:new CANNON.Plane()}); gnd.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(gnd);
const plane=new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshStandardMaterial({color:0x111111,roughness:.92})); plane.rotation.x=-Math.PI/2; plane.receiveShadow=true; scene.add(plane);
const grid=new THREE.GridHelper(10,20,0x00ff00,0x003300); grid.position.y=.01; scene.add(grid);

// HUD refs
const hudS=document.getElementById('hudScore');
const hudH=document.getElementById('hudH');
const hudStreak=document.getElementById('hudS');
const hudHi=document.getElementById('hudHi'); hudHi.textContent=high;
const hudStab=document.getElementById('hudStab');
const preview=document.getElementById('preview');

/* Controls */
const controls=document.getElementById('controls');
const bDrop=document.getElementById('bDrop');
const bLeft=document.getElementById('bLeft');
const bRight=document.getElementById('bRight');
const bCull=document.getElementById('bCull');
const bView=document.getElementById('bView');
const bMute=document.getElementById('bMute');
const over=document.getElementById('over');
const final=document.getElementById('final');
const bRestart=document.getElementById('bRestart');

bDrop.onclick=dropTV; bLeft.onclick=()=>nudge(-1); bRight.onclick=()=>nudge(1); bCull.onclick=cull; bView.onclick=cycleCam; bMute.onclick=toggleMute; bRestart.onclick=restart;

// Gestures: swipe ↑ drop, ◀/▶ nudge, ↓ cull
let swipeStart=null, swipeT=null; 
const SWIPE=20; // px threshold per 100ms
addEventListener('touchstart',e=>{ if(e.touches.length!==1) return; swipeStart={x:e.touches[0].clientX, y:e.touches[0].clientY, t:performance.now()}; swipeT=swipeStart; controls.classList.add('fade'); });
addEventListener('touchmove',e=>{ if(!swipeStart) return; swipeT={x:e.touches[0].clientX,y:e.touches[0].clientY,t:performance.now()}; });
addEventListener('touchend',()=>{
  if(!swipeStart||!swipeT){ swipeStart=null; swipeT=null; return; }
  const dx=swipeT.x-swipeStart.x, dy=swipeT.y-swipeStart.y, dt=Math.max(1,swipeT.t-swipeStart.t);
  const vx=dx/dt*100, vy=dy/dt*100;
  if(Math.abs(vy)<Math.abs(vx)){
    if(vx>SWIPE) nudge(1); else if(vx<-SWIPE) nudge(-1);
  }else{
    if(-vy>SWIPE) dropTV(); else if(vy>SWIPE) cull();
  }
  controls.classList.remove('fade');
  swipeStart=null; swipeT=null;
});

// Auto-fade controls during play to keep stack visible
let fadeTimer=null; function userAct(){ lastTouch=Date.now(); controls.classList.remove('fade'); clearTimeout(fadeTimer); fadeTimer=setTimeout(()=>controls.classList.add('fade'), 1600); }
['click','touchstart'].forEach(ev=>addEventListener(ev,userAct));

updatePreview();
animate();

/***** Cycle camera (placed AFTER beep is defined) *****/
function cycleCam(){ camI=(camI+1)%cams.length; setCam(camI); beep('triangle',660,.06,.02); }

/***** Core Game *****/
function dropTV(){ if(gameOver||falling) return; const y=tvs.length? Math.max(...tvs.map(t=>t.group.position.y))+TV.h+GAP+2 : 5; falling=createTV(y); tvs.push(falling); bDrop.disabled=true; sndDrop(); buzz(15); }
function nudge(dir){ if(!falling||falling.settled) return; falling.body.applyImpulse(new CANNON.Vec3(dir*2,0,0), falling.body.position); sndNudge(); buzz(7); }
function cull(){ if(!tvs.length||gameOver) return; const bot=tvs.shift(); scene.remove(bot.group); world.removeBody(bot.body); bot.video?.pause(); streak=0; updateHUD(); buzz([18,28]); }
function toggleMute(){ muted=!muted; tvs.forEach(t=>t.video&&(t.video.muted=muted)); bMute.textContent=muted?'UNMUTE':'MUTE' }

function createTV(y=5){
  const g=new THREE.Group();
  // Shell
  const shell=new THREE.Mesh(new THREE.BoxGeometry(TV.w,TV.h,TV.d), new THREE.MeshStandardMaterial({color:0x2a2a2a,roughness:.86,metalness:.05})); shell.castShadow=true; shell.receiveShadow=true; g.add(shell);
  // Screen (video or noise)
  const video=document.createElement('video'); video.src=FEED[feedI%FEED.length]; feedI++; video.loop=true; video.muted=muted; video.playsInline=true; video.crossOrigin='anonymous';
  let tex, mat; 
  const valid=video.src.includes('/videos/');
  function noise(){ mat=new THREE.ShaderMaterial({vertexShader:v, fragmentShader:fNoise, uniforms:{t:{value:Math.random()*100}}}); }
  if(valid){ video.play().catch(()=>noise()); tex=new THREE.VideoTexture(video); tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter; mat=new THREE.MeshBasicMaterial({map:tex}); }
  else noise();
  const screen=new THREE.Mesh(new THREE.PlaneGeometry(TV.w*.84, TV.h*.7), mat); screen.position.z=TV.d/2+.001; g.add(screen);
  // Glass shader overlay
  const glassMat=new THREE.ShaderMaterial({vertexShader:v, fragmentShader:fGlass, uniforms:{tex:{value:tex||new THREE.Texture()}, t:{value:0}, pulse:{value:0}}, transparent:true});
  const glass=new THREE.Mesh(new THREE.PlaneGeometry(TV.w*.84, TV.h*.7), glassMat); glass.position.z=TV.d/2+.002; g.add(glass);
  // LED
  const led=new THREE.Mesh(new THREE.PlaneGeometry(.03,.03), new THREE.MeshBasicMaterial({color:0x00ff00})); led.position.set(TV.w*.35,-TV.h*.35, TV.d/2+.001); g.add(led);

  g.position.y=y; scene.add(g);

  const body=new CANNON.Body({mass:1, shape:new CANNON.Box(new CANNON.Vec3(TV.w/2,TV.h/2,TV.d/2)), sleepSpeedLimit:.1, sleepTimeLimit:.5}); body.position.copy(g.position); body.linearDamping=.3; body.angularDamping=.3; world.addBody(body);
  return {group:g, body, video, screen, glassMat, led, settled:false, pulse:0, lastMutate:0};
}

function calcStability(){ if(tvs.length<2) return 1; const r=tvs.slice(-WINDOW_K).filter(t=>t.settled); if(r.length<2) return 1; let com=0, over=0; for(let i=1;i<r.length;i++){ const a=r[i], b=r[i-1]; const off=Math.hypot(a.body.position.x-b.body.position.x, a.body.position.z-b.body.position.z); com+=off/LIMIT; const oh=Math.max(0, off - TV.w*.3); over+=oh/(TV.w*.7); } const n=r.length-1; return THREE.MathUtils.clamp(1-(com/n + ALPHA*(over/n)), 0, 1); }

function topple(){ if(gameOver) return; gameOver=true; world.gravity.y*=.35; sndOver(); buzz([80,30,80,30,120]); if(score>high){ high=score; localStorage.setItem('tv_hi',String(high)); }
  setTimeout(()=>{ final.textContent=`FINAL SCORE: ${score} — HEIGHT: ${height.toFixed(2)}m`; over.style.display='grid'; }, 900);
}

function restart(){ tvs.forEach(t=>{scene.remove(t.group); world.removeBody(t.body); t.video?.pause();}); tvs.length=0; falling=null; score=height=streak=0; stability=1; gameOver=false; feedI=0; world.gravity.y=-9.82; over.style.display='none'; bDrop.disabled=false; updateHUD(); }

/***** Loop *****/
function animate(){ requestAnimationFrame(animate); const dt=Math.min(clock.getDelta(),.1); world.step(1/60, dt, 3);
  const t=clock.getElapsedTime();
  tvs.forEach((tv)=>{
    tv.group.position.copy(tv.body.position); tv.group.quaternion.copy(tv.body.quaternion);
    if(!tv.settled && tv.body.sleepState===CANNON.Body.SLEEPING){ tv.settled=true; sndThump(); buzz(10); if(tv===falling){ const bonus=Math.floor(tv.body.position.y*10); score+=10+bonus; streak++; score+=streak*2; falling=null; bDrop.disabled=false; updatePreview(); } }
    if(tv.settled) height=Math.max(height, tv.body.position.y);
    if(tv.glassMat){ tv.glassMat.uniforms.t.value=t; tv.glassMat.uniforms.pulse.value=Math.max(0, tv.pulse-=dt*2); }
    if(tv.screen.material.uniforms?.t) tv.screen.material.uniforms.t.value+=dt;
  });
  stability=calcStability(); if(stability<=0 && !gameOver) topple();
  updateHUD(); renderer.render(scene,camera);
}

/***** HUD helpers *****/
function updateHUD(){ hudS.textContent=`SCORE: ${score}`; hudH.textContent=height.toFixed(2); hudStreak.textContent=streak; hudHi.textContent=high; hudStab.style.width=`${stability*100}%`; }
function updatePreview(){ // simple animated scan bar
  preview.style.background=`linear-gradient(#0a0a0a,#0a0a0a), repeating-linear-gradient(180deg,#111 0,#111 2px,#0f0 3px,#111 4px)`;
}

/***** Resize *****/
addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

/***** Minimal runtime self-tests ("test cases") *****/
(function runSelfTests(){
  console.log('%c[VIDEO_STACKER_∞] running self-tests…','color:#19ff48');
  console.assert(Array.isArray(cams) && cams.length>0, 'cams should be pre-defined');
  console.assert(typeof setCam==='function', 'setCam should be a function');
  const p0=camera.position.clone(); setCam(0); const p1=camera.position.clone();
  console.assert(!p0.equals(p1) || p0.distanceTo(p1)>=0, 'setCam(0) should be callable without throwing');
  console.assert(typeof world==='object' && typeof renderer==='object', 'world & renderer should exist');
})();

</script>
</body>
</html>
