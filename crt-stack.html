<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>CRT Stack √ó Filing Cabinet</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body {
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: #1a1a1a;
  touch-action: pan-y;
}

#container {
  position: fixed;
  inset: 0;
}

#webgl, #css3d {
  position: absolute;
  inset: 0;
}

#css3d {
  pointer-events: none;
}

#css3d iframe {
  pointer-events: auto;
}

#controller {
  position: fixed;
  bottom: env(safe-area-inset-bottom, 0);
  left: 0;
  right: 0;
  background: rgba(20, 20, 20, 0.95);
  backdrop-filter: blur(10px);
  padding: 12px;
  z-index: 1000;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.view-toggles {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}

.view-btn {
  min-width: 44px;
  height: 44px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  color: #fff;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.2s;
  padding: 4px 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
}

.view-btn:active {
  transform: scale(0.95);
}

.view-btn.active {
  background: rgba(100, 150, 255, 0.4);
  border-color: rgba(100, 150, 255, 0.6);
}

.view-icon {
  font-size: 16px;
}

.stack-selector {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-top: 8px;
}

.stack-nav {
  min-width: 44px;
  height: 44px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-size: 18px;
}

.stack-dots {
  display: flex;
  gap: 8px;
}

.stack-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transition: all 0.3s;
}

.stack-dot.active {
  background: rgba(100, 150, 255, 0.8);
  transform: scale(1.3);
}

#top-controls {
  position: fixed;
  top: env(safe-area-inset-top, 12px);
  right: 12px;
  display: flex;
  gap: 8px;
  z-index: 1000;
}

.top-btn {
  width: 44px;
  height: 44px;
  background: rgba(20, 20, 20, 0.9);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-size: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.drawer-controls {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(20, 20, 20, 0.95);
  backdrop-filter: blur(10px);
  padding: 16px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  display: none;
  gap: 8px;
  z-index: 999;
}

.drawer-controls.active {
  display: flex;
}

.drawer-btn {
  width: 44px;
  height: 44px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-size: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#audio-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

#audio-overlay.show {
  display: flex;
}

.audio-prompt {
  background: rgba(40, 40, 40, 0.95);
  padding: 32px;
  border-radius: 16px;
  text-align: center;
  color: #fff;
}

.audio-prompt button {
  margin-top: 20px;
  padding: 12px 32px;
  background: rgba(100, 150, 255, 0.4);
  border: 1px solid rgba(100, 150, 255, 0.6);
  border-radius: 8px;
  color: #fff;
  font-size: 16px;
  cursor: pointer;
}
</style>
</head>
<body>

<div id="container">
  <div id="webgl"></div>
  <div id="css3d"></div>
</div>

<div id="top-controls">
  <button class="top-btn" id="mute-btn" aria-label="Toggle mute">üîá</button>
  <button class="top-btn" id="theme-btn" aria-label="Toggle theme">üé®</button>
</div>

<div id="controller">
  <div class="view-toggles">
    <button class="view-btn active" data-view="front" aria-label="Front view">
      <span class="view-icon">‚¨ú</span>
      <span>Front</span>
    </button>
    <button class="view-btn" data-view="isoLeft" aria-label="Three quarter left view">
      <span class="view-icon">‚ó∞</span>
      <span>¬æL</span>
    </button>
    <button class="view-btn" data-view="isoRight" aria-label="Three quarter right view">
      <span class="view-icon">‚ó≥</span>
      <span>¬æR</span>
    </button>
    <button class="view-btn" data-view="side" aria-label="Side view">
      <span class="view-icon">‚ñ≠</span>
      <span>Side</span>
    </button>
    <button class="view-btn" data-view="lowHero" aria-label="Low hero view">
      <span class="view-icon">‚¨Ü</span>
      <span>Low</span>
    </button>
    <button class="view-btn" data-view="top" aria-label="Top view">
      <span class="view-icon">‚¨õ</span>
      <span>Top</span>
    </button>
  </div>
  <div class="stack-selector">
    <button class="stack-nav" id="prev-stack" aria-label="Previous stack">‚Äπ</button>
    <div class="stack-dots" id="stack-dots"></div>
    <button class="stack-nav" id="next-stack" aria-label="Next stack">‚Ä∫</button>
  </div>
</div>

<div class="drawer-controls" id="drawer-controls">
  <button class="drawer-btn" id="play-btn" aria-label="Play pause">‚ñ∂</button>
  <button class="drawer-btn" id="prev-vid" aria-label="Previous video">‚èÆ</button>
  <button class="drawer-btn" id="next-vid" aria-label="Next video">‚è≠</button>
</div>

<div id="audio-overlay">
  <div class="audio-prompt">
    <h2>Enable Audio?</h2>
    <p>Tap to unmute and start playback</p>
    <button id="enable-audio">Enable Audio</button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// New 13-segment video
const VIDEO_ID = 'uDUoMnp1z_g';
const TIMESTAMPS = [
  0,      // Out of Life (0:00)
  136,    // Flashing Lights (2:16)
  272,    // How to Break Off an Engagement (4:32)
  408,    // Nevermore (6:48)
  544,    // Bloodline (9:04)
  680,    // Resurrecting Atlantis (11:20)
  816,    // DJ Turn Me Up (13:36)
  952,    // Newly Single (15:52)
  1088,   // Yet, Heard (18:08)
  1224,   // Magic Ride (20:24)
  1360,   // Reunion (22:40)
  1496,   // How to Win My Heart (24:56)
  1632    // Hot Minute (27:12)
];

const NUM_STACKS = 6; // 6 sets of 3 TVs in a circle
const STACKS = [];

for (let i = 0; i < NUM_STACKS; i++) {
  STACKS.push({
    name: String.fromCharCode(65 + i), // A, B, C, D, E, F
    tvs: [
      { slot: "top", videoId: VIDEO_ID, timestamp: TIMESTAMPS[i * 3 % TIMESTAMPS.length] },
      { slot: "middle", videoId: VIDEO_ID, timestamp: TIMESTAMPS[(i * 3 + 1) % TIMESTAMPS.length] },
      { slot: "bottom", videoId: VIDEO_ID, timestamp: TIMESTAMPS[(i * 3 + 2) % TIMESTAMPS.length] }
    ]
  });
}

const VIEWS = {
  front: { pos: [0, 1.2, 2.4], look: [0, 1.0, 0] },
  isoLeft: { pos: [-1.2, 1.4, 2.2], look: [0, 1.0, 0] },
  isoRight: { pos: [1.2, 1.4, 2.2], look: [0, 1.0, 0] },
  side: { pos: [2.4, 1.2, 0.2], look: [0, 1.0, 0] },
  lowHero: { pos: [0, 0.6, 2.1], look: [0, 1.0, 0.1] },
  top: { pos: [0, 2.3, 1.6], look: [0, 1.0, 0] }
};

const CAROUSEL_RADIUS = 2.2; // Closer circle radius for mobile
const AUTO_ROTATE_SPEED = 0.2; // Slightly faster rotation
const DRAWER_OPEN_DIST = 0.14;

let state = {
  activeStack: 0,
  activeView: 'front',
  openDrawer: null,
  muted: true,
  theme: 'studio',
  audioEnabled: false,
  videoIndices: {},
  autoRotate: true,
  rotationAngle: 0
};

try {
  const saved = localStorage.getItem('crt-state');
  if (saved) {
    const savedState = JSON.parse(saved);
    state = { ...state, ...savedState, autoRotate: true }; // Always auto-rotate on load
  }
} catch (e) {}

function saveState() {
  try {
    localStorage.setItem('crt-state', JSON.stringify(state));
  } catch (e) {}
}

class Tween {
  constructor(from, to, duration, onUpdate, onComplete) {
    this.from = from;
    this.to = to;
    this.duration = duration;
    this.onUpdate = onUpdate;
    this.onComplete = onComplete;
    this.startTime = performance.now();
    this.active = true;
  }

  update(now) {
    if (!this.active) return false;
    const elapsed = now - this.startTime;
    const progress = Math.min(elapsed / this.duration, 1);
    const eased = this.easeInOut(progress);
    
    if (Array.isArray(this.from)) {
      const current = this.from.map((f, i) => f + (this.to[i] - f) * eased);
      this.onUpdate(current);
    } else {
      this.onUpdate(this.from + (this.to - this.from) * eased);
    }

    if (progress >= 1) {
      this.active = false;
      if (this.onComplete) this.onComplete();
      return false;
    }
    return true;
  }

  easeInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
}

const activeTweens = [];

const container = document.getElementById('container');
const webglEl = document.getElementById('webgl');
const css3dEl = document.getElementById('css3d');

const scene = new THREE.Scene();
const sceneCSS = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
const cameraTarget = new THREE.Vector3(0, 1.0, 0);
camera.position.set(0, 1.5, 4.0); // Good viewing distance
camera.lookAt(cameraTarget);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x1a1a1a); // Darker for contrast
webglEl.appendChild(renderer.domElement);

const CSS3DRenderer = function() {
  const domElement = document.createElement('div');
  domElement.style.overflow = 'hidden';
  this.domElement = domElement;

  const cameraElement = document.createElement('div');
  cameraElement.style.transformStyle = 'preserve-3d';
  domElement.appendChild(cameraElement);

  this.render = function(scene, camera) {
    const fov = camera.projectionMatrix.elements[5] * (window.innerHeight / 2);
    const cameraMat = camera.matrixWorldInverse;
    const e = cameraMat.elements;
    const matrix = `matrix3d(${e[0]},${-e[1]},${e[2]},${e[3]},${e[4]},${-e[5]},${e[6]},${e[7]},${e[8]},${-e[9]},${e[10]},${e[11]},${e[12]},${-e[13]},${e[14]},${e[15]})`;
    cameraElement.style.transform = `translateZ(${fov}px)${matrix} translate3d(${window.innerWidth/2}px,${window.innerHeight/2}px,0)`;
  };

  this.setSize = function(width, height) {
    domElement.style.width = width + 'px';
    domElement.style.height = height + 'px';
  };
};

class CSS3DObject extends THREE.Object3D {
  constructor(element) {
    super();
    this.element = element;
    this.element.style.position = 'absolute';
    this.element.style.pointerEvents = 'auto';
    
    this.addEventListener('removed', () => {
      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
    });
  }
}

const cssRenderer = new CSS3DRenderer();
cssRenderer.setSize(window.innerWidth, window.innerHeight);
css3dEl.appendChild(cssRenderer.domElement);

// Brighter lighting for mobile visibility
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);

const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
keyLight.position.set(2, 4, 3);
scene.add(keyLight);

const fillLight = new THREE.DirectionalLight(0x8899ff, 0.4);
fillLight.position.set(-2, 2, -1);
scene.add(fillLight);

// Create infinite grid effect instead of solid floor
const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
gridHelper.position.y = -0.5;
gridHelper.material.opacity = 0.3;
gridHelper.material.transparent = true;
scene.add(gridHelper);

// Add fog for infinite depth impression
scene.fog = new THREE.FogExp2(0x1a1a1a, 0.15);

const stacksGroup = new THREE.Group();
scene.add(stacksGroup);

const stacksGroupCSS = new THREE.Group();
sceneCSS.add(stacksGroupCSS);

const stacks = [];
const players = {};

STACKS.forEach((stackData, stackIdx) => {
  const stackGroup = new THREE.Group();
  
  // Position in circle
  const angle = (stackIdx / NUM_STACKS) * Math.PI * 2;
  stackGroup.position.x = Math.cos(angle) * CAROUSEL_RADIUS;
  stackGroup.position.z = Math.sin(angle) * CAROUSEL_RADIUS;
  stackGroup.rotation.y = angle + Math.PI; // Face outward toward camera
  
  stacksGroup.add(stackGroup);

  const stackGroupCSS = new THREE.Group();
  stackGroupCSS.position.x = Math.cos(angle) * CAROUSEL_RADIUS;
  stackGroupCSS.position.z = Math.sin(angle) * CAROUSEL_RADIUS;
  stackGroupCSS.rotation.y = angle + Math.PI; // Face outward
  stacksGroupCSS.add(stackGroupCSS);

  const tvs = [];

  stackData.tvs.forEach((tvData, tvIdx) => {
    const yPos = 1.5 - tvIdx * 0.55; // Better vertical spacing
    
    const drawerGroup = new THREE.Group();
    drawerGroup.position.y = yPos;
    stackGroup.add(drawerGroup);

    const drawerCSS = new THREE.Group();
    drawerCSS.position.y = yPos;
    stackGroupCSS.add(drawerCSS);

    const cabinetMat = new THREE.MeshStandardMaterial({ 
      color: 0x2a2a2a, 
      roughness: 0.5,
      metalness: 0.2
    });

    // Larger TVs for mobile visibility
    const frameGeo = new THREE.BoxGeometry(0.56, 0.56, 0.4);
    const frame = new THREE.Mesh(frameGeo, cabinetMat);
    frame.position.z = -0.2;
    drawerGroup.add(frame);

    const crtBody = new THREE.BoxGeometry(0.46, 0.36, 0.32);
    const crtMat = new THREE.MeshStandardMaterial({ 
      color: 0x1a1a1a, 
      roughness: 0.4 
    });
    const crt = new THREE.Mesh(crtBody, crtMat);
    drawerGroup.add(crt);

    const screenGeo = new THREE.PlaneGeometry(0.36, 0.27); // Larger screen
    const screenMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const screen = new THREE.Mesh(screenGeo, screenMat);
    screen.position.z = 0.161; // Adjusted for larger body
    drawerGroup.add(screen);

    const glassMat = new THREE.ShaderMaterial({
      transparent: true,
      uniforms: { time: { value: 0 } },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        varying vec2 vUv;
        void main() {
          float scanline = sin(vUv.y * 300.0 + time * 0.001) * 0.03;
          float vignette = 1.0 - length(vUv - 0.5) * 0.4;
          gl_FragColor = vec4(0.1, 0.15, 0.2, 0.15 + scanline) * vignette;
        }
      `
    });
    const glass = new THREE.Mesh(screenGeo, glassMat);
    glass.position.z = 0.162;
    drawerGroup.add(glass);

    const ledGeo = new THREE.SphereGeometry(0.008, 8, 8);
    const ledMat = new THREE.MeshBasicMaterial({ 
      color: 0xff3333, 
      emissive: 0xff0000,
      emissiveIntensity: 0.8
    });
    const led = new THREE.Mesh(ledGeo, ledMat);
    led.position.set(0.20, -0.15, 0.16); // Adjusted for larger TV
    drawerGroup.add(led);

    const handleGeo = new THREE.BoxGeometry(0.16, 0.03, 0.03); // Larger handle
    const handle = new THREE.Mesh(handleGeo, cabinetMat);
    handle.position.set(0, -0.12, 0.161);
    handle.userData.drawerIndex = tvIdx;
    handle.userData.stackIndex = stackIdx;
    handle.userData.isHandle = true;
    drawerGroup.add(handle);

    const iframe = document.createElement('iframe');
    const vidKey = `${stackIdx}-${tvIdx}`;
    const videoId = tvData.videoId;
    const timestamp = tvData.timestamp;
    
    iframe.src = `https://www.youtube.com/embed/${videoId}?enablejsapi=1&mute=${state.muted ? 1 : 0}&autoplay=1&controls=0&cc_load_policy=1&start=${timestamp}&loop=1&playlist=${videoId}`;
    iframe.style.width = '640px'; // Higher res for clarity
    iframe.style.height = '480px';
    iframe.style.border = 'none';
    iframe.allow = 'autoplay';

    const cssObject = new CSS3DObject(iframe);
    cssObject.position.z = 0.161;
    cssObject.scale.set(0.0005625, 0.0005625, 1); // Scale to match 0.36 / 640
    drawerCSS.add(cssObject);

    players[vidKey] = {
      iframe,
      videoId: tvData.videoId,
      timestamp: tvData.timestamp,
      playing: false
    };

    tvs.push({ drawerGroup, drawerCSS, handle, screen, glass, iframe });
  });

  stacks.push({ stackGroup, stackGroupCSS, tvs });
});

const dotsContainer = document.getElementById('stack-dots');
STACKS.forEach((_, idx) => {
  const dot = document.createElement('div');
  dot.className = `stack-dot ${idx === state.activeStack ? 'active' : ''}`;
  dotsContainer.appendChild(dot);
});

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onPointerDown(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  
  const allHandles = [];
  stacks.forEach(stack => {
    stack.tvs.forEach(tv => allHandles.push(tv.handle));
  });

  const intersects = raycaster.intersectObjects(allHandles);
  
  if (intersects.length > 0) {
    const obj = intersects[0].object;
    if (obj.userData.isHandle) {
      openDrawer(obj.userData.stackIndex, obj.userData.drawerIndex);
      vibrate(10);
    }
  }
}

renderer.domElement.addEventListener('pointerdown', onPointerDown);

function openDrawer(stackIdx, drawerIdx) {
  if (state.openDrawer) {
    const [prevStack, prevDrawer] = state.openDrawer;
    const prevTv = stacks[prevStack].tvs[prevDrawer];
    tweenDrawer(prevTv.drawerGroup, prevTv.drawerCSS, 0);
  }

  const tv = stacks[stackIdx].tvs[drawerIdx];
  tweenDrawer(tv.drawerGroup, tv.drawerCSS, DRAWER_OPEN_DIST);
  
  state.openDrawer = [stackIdx, drawerIdx];
  
  document.getElementById('drawer-controls').classList.add('active');
  updateDrawerControls();
}

function tweenDrawer(group, groupCSS, targetZ, duration = 320) {
  const startZ = group.position.z;
  activeTweens.push(new Tween(startZ, targetZ, duration, (z) => {
    group.position.z = z;
    groupCSS.position.z = z;
  }));
}

function updateDrawerControls() {
  if (!state.openDrawer) return;
  const [stackIdx, drawerIdx] = state.openDrawer;
  const vidKey = `${stackIdx}-${drawerIdx}`;
  const player = players[vidKey];
  document.getElementById('play-btn').textContent = player.playing ? '‚è∏' : '‚ñ∂';
}

function tweenCamera(targetView, duration = 400) {
  const view = VIEWS[targetView];
  const startPos = camera.position.toArray();
  const startLook = cameraTarget.toArray();

  activeTweens.push(new Tween(startPos, view.pos, duration, (pos) => camera.position.set(...pos)));
  activeTweens.push(new Tween(startLook, view.look, duration, (look) => {
    cameraTarget.set(...look);
    camera.lookAt(cameraTarget);
  }));
}

function tweenStackPosition(targetIndex, duration = 450) {
  const startAngle = state.rotationAngle;
  const targetAngle = (targetIndex / NUM_STACKS) * Math.PI * 2;
  
  activeTweens.push(new Tween(startAngle, targetAngle, duration, (angle) => { 
    state.rotationAngle = angle;
    stacksGroup.rotation.y = angle;
    stacksGroupCSS.rotation.y = angle;
  }));
  
  // Keep auto-rotating even when manually switching
}

document.querySelectorAll('.view-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const view = btn.dataset.view;
    if (view === state.activeView) return;
    state.activeView = view;
    tweenCamera(view);
    vibrate(5);
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    saveState();
  });
});

document.getElementById('prev-stack').addEventListener('click', () => {
  if (state.activeStack > 0) switchStack(state.activeStack - 1);
});

document.getElementById('next-stack').addEventListener('click', () => {
  if (state.activeStack < STACKS.length - 1) switchStack(state.activeStack + 1);
});

function switchStack(newIdx) {
  state.activeStack = newIdx;
  tweenStackPosition(newIdx);
  vibrate(8);
  document.querySelectorAll('.stack-dot').forEach((dot, idx) => {
    dot.classList.toggle('active', idx === newIdx);
  });
  Object.keys(players).forEach(key => {
    const [stackIdx] = key.split('-').map(Number);
    if (stackIdx !== newIdx) pausePlayer(key);
  });
  saveState();
}

document.getElementById('play-btn').addEventListener('click', () => {
  if (!state.openDrawer) return;
  const [stackIdx, drawerIdx] = state.openDrawer;
  togglePlay(`${stackIdx}-${drawerIdx}`);
});

document.getElementById('prev-vid').addEventListener('click', () => {
  if (!state.openDrawer) return;
  const [stackIdx, drawerIdx] = state.openDrawer;
  changeVideo(`${stackIdx}-${drawerIdx}`, -1);
});

document.getElementById('next-vid').addEventListener('click', () => {
  if (!state.openDrawer) return;
  const [stackIdx, drawerIdx] = state.openDrawer;
  changeVideo(`${stackIdx}-${drawerIdx}`, 1);
});

function togglePlay(vidKey) {
  const player = players[vidKey];
  if (!player) return;

  if (!state.audioEnabled) {
    document.getElementById('audio-overlay').classList.add('show');
    return;
  }

  const cmd = player.playing ? 'pauseVideo' : 'playVideo';
  player.iframe.contentWindow.postMessage(`{"event":"command","func":"${cmd}","args":""}`, '*');
  player.playing = !player.playing;
  updateDrawerControls();
  vibrate(5);
}

function pausePlayer(vidKey) {
  const player = players[vidKey];
  if (!player || !player.playing) return;
  player.iframe.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
  player.playing = false;
}

function changeVideo(vidKey, direction) {
  const player = players[vidKey];
  if (!player) return;
  
  // Cycle through timestamps
  const currentIdx = TIMESTAMPS.indexOf(player.timestamp);
  const newIdx = (currentIdx + direction + TIMESTAMPS.length) % TIMESTAMPS.length;
  player.timestamp = TIMESTAMPS[newIdx];
  
  player.iframe.src = `https://www.youtube.com/embed/${player.videoId}?enablejsapi=1&mute=${state.muted ? 1 : 0}&autoplay=${player.playing ? 1 : 0}&controls=0&cc_load_policy=1&start=${player.timestamp}&loop=1&playlist=${player.videoId}`;
  
  saveState();
  vibrate(8);
}

document.getElementById('mute-btn').addEventListener('click', () => {
  state.muted = !state.muted;
  document.getElementById('mute-btn').textContent = state.muted ? 'üîá' : 'üîä';
  Object.keys(players).forEach(key => {
    const cmd = state.muted ? 'mute' : 'unMute';
    players[key].iframe.contentWindow.postMessage(`{"event":"command","func":"${cmd}","args":""}`, '*');
  });
  saveState();
  vibrate(5);
});

document.getElementById('theme-btn').addEventListener('click', () => {
  state.theme = state.theme === 'studio' ? 'gallery' : 'studio';
  if (state.theme === 'gallery') {
    renderer.setClearColor(0xf0f0f0);
    floorMat.color.setHex(0xe0e0e0);
    wallMat.color.setHex(0xf5f5f5);
  } else {
    renderer.setClearColor(0x2a2a2a);
    floorMat.color.setHex(0x333333);
    wallMat.color.setHex(0x3a3a3a);
  }
  saveState();
  vibrate(5);
});

document.getElementById('enable-audio').addEventListener('click', () => {
  state.audioEnabled = true;
  state.muted = false;
  document.getElementById('mute-btn').textContent = 'üîä';
  document.getElementById('audio-overlay').classList.remove('show');
  Object.keys(players).forEach(key => {
    players[key].iframe.contentWindow.postMessage('{"event":"command","func":"unMute","args":""}', '*');
  });
  saveState();
});

let touchStartX = 0;
let touchStartY = 0;

renderer.domElement.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});

renderer.domElement.addEventListener('touchend', (e) => {
  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;
  
  if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
    if (deltaX > 0 && state.activeStack > 0) {
      switchStack(state.activeStack - 1);
    } else if (deltaX < 0 && state.activeStack < STACKS.length - 1) {
      switchStack(state.activeStack + 1);
    }
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === '1' || e.key === '2' || e.key === '3') {
    const drawerIdx = parseInt(e.key) - 1;
    openDrawer(state.activeStack, drawerIdx);
  }
  
  if (e.key === 'ArrowLeft' && state.activeStack > 0) {
    switchStack(state.activeStack - 1);
  }
  
  if (e.key === 'ArrowRight' && state.activeStack < STACKS.length - 1) {
    switchStack(state.activeStack + 1);
  }
  
  if (e.key === 'v' || e.key === 'V') {
    const views = Object.keys(VIEWS);
    const currentIdx = views.indexOf(state.activeView);
    const nextIdx = (currentIdx + 1) % views.length;
    const nextView = views[nextIdx];
    state.activeView = nextView;
    tweenCamera(nextView);
    document.querySelectorAll('.view-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.view === nextView);
    });
  }
  
  if (e.key === ' ' && state.openDrawer) {
    e.preventDefault();
    const [stackIdx, drawerIdx] = state.openDrawer;
    togglePlay(`${stackIdx}-${drawerIdx}`);
  }
});

function vibrate(duration) {
  if (navigator.vibrate) {
    navigator.vibrate(duration);
  }
}

let resizeTimeout;
function onResize() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    cssRenderer.setSize(window.innerWidth, window.innerHeight);
  }, 100);
}

window.addEventListener('resize', onResize);

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    Object.keys(players).forEach(key => pausePlayer(key));
  }
});

let lastTime = performance.now();

function animate(now) {
  requestAnimationFrame(animate);
  
  // Auto-rotate carousel
  if (state.autoRotate) {
    state.rotationAngle += AUTO_ROTATE_SPEED * (Math.PI / 180);
    stacksGroup.rotation.y = state.rotationAngle;
    stacksGroupCSS.rotation.y = state.rotationAngle;
  }
  
  for (let i = activeTweens.length - 1; i >= 0; i--) {
    if (!activeTweens[i].update(now)) {
      activeTweens.splice(i, 1);
    }
  }
  
  stacks.forEach(stack => {
    stack.tvs.forEach(tv => {
      if (tv.glass.material.uniforms) {
        tv.glass.material.uniforms.time.value = now;
      }
    });
  });
  
  cssRenderer.render(sceneCSS, camera);
  renderer.render(scene, camera);
}

stacksGroup.rotation.y = state.rotationAngle;
stacksGroupCSS.rotation.y = state.rotationAngle;

if (state.activeView !== 'front') {
  camera.position.set(...VIEWS[state.activeView].pos);
  cameraTarget.set(...VIEWS[state.activeView].look);
  camera.lookAt(cameraTarget);
}

document.getElementById('mute-btn').textContent = state.muted ? 'üîá' : 'üîä';

if (state.theme === 'gallery') {
  renderer.setClearColor(0xf0f0f0);
  floorMat.color.setHex(0xe0e0e0);
  wallMat.color.setHex(0xf5f5f5);
}

animate(performance.now());
</script>
</body>
</html>